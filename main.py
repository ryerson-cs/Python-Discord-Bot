import discord
from discord.ext import commands
import asyncio
import emoji
import urllib.request
from bs4 import BeautifulSoup
import json
import random
import requests
import re
from random import randint

"""bot-env\Scripts\activate.bat"""

### Setup
client = discord.Client()
bot = commands.Bot(command_prefix = "$")
bot.activity = discord.Game("{0}help for commands.".format(bot.command_prefix)) #Please override later
bot.remove_command("help")


### Helpers
def read_token():
    with open("token.key", "r") as f:
        lines = f.readlines()
        return lines[0].strip()

async def find_reddit_link(subreddit):
    url = "https://old.reddit.com/r/" + subreddit
    headers = {'user-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.3'}
    try:    
        request = urllib.request.Request(url,headers=headers)
        html = urllib.request.urlopen(request).read()
        scrapper = BeautifulSoup(html,'html.parser')
        table = scrapper.find("div",attrs={'id':'siteTable'})
    except:
        return "Not Found"

    try:
        links = table.find_all("a",class_="title")
    except:
        return "NSFW"
    extracted_records = []
    for link in links: 
        title = link.text
        url = link['href']
       
        if not url.startswith('http'):
            url = "https://reddit.com"+url 
     
        record = {
            'Title':title,
            'Post':url
            }
        extracted_records.append(record)
    return extracted_records
### Events
@bot.event
async def on_ready():
    print("API Version: {0}".format(discord.__version__))
    print("We have logged in as {0.user}".format(bot))

@bot.event
async def on_command_error(ctx, error):
    await ctx.send(error)

### Commands
@bot.command()
async def help(ctx):
    e = discord.Embed(
        title = "PyBot Commands - Created by Alex Massin & Alex Gomes",
        description = "All available commands provided by PyBot.",
        color = 0XFFDF00
    )
    
    e.set_thumbnail(url = bot.user.avatar_url)
    
    e.add_field(
        name = "{0}ping".format(bot.command_prefix),
        value = "Returns the latency of the bot's response.",
        inline = False
    )

    e.add_field(
        name = "{0}avatar <<user>>".format(bot.command_prefix),
        value = "Returns the avatar of a user.",
        inline = False
    )

    e.add_field(
        name = "{0}say <<message>>".format(bot.command_prefix),
        value = "Says a custom message provided by the user.",
        inline = False
    )

    e.add_field(
        name = "{0}story <<message>>".format(bot.command_prefix),
        value = "Creates custom story out of emojis provided by the user.",
        inline = False
    )
    e.add_field(
        name = "{0}reddit <<subreddit>>".format(bot.command_prefix),
        value = "Generates random post from given subreddit.",
        inline = False
    )
    e.add_field(
        name = "{0}subreddit <<subreddit>>".format(bot.command_prefix),
        value = "Generates top 5 hot posts from given subreddit.",
        inline = False
    )
    #e.add_field(
    #    name = "{0}google <<word>>".format(bot.command_prefix),
    #    value = "Generates definition from Google.",
    #    inline = False
    #)
    e.add_field(
        name = "{0}define <<word>>".format(bot.command_prefix),
        value = "Returns dictionary definition.",
        inline = False
    )
    e.add_field(
        name = "{0}verbose <<sentence>>".format(bot.command_prefix),
        value = "Changes your sentence words with their synonyms.",
        inline = False
    )
    e.add_field(
        name = "{0}8ball <<sentence>>".format(bot.command_prefix),
        value = "Ask a question and get a random, classic 8ball response.",
        inline = False
    )
    e.add_field(
        name = "{0}inspiro <<sentence>>".format(bot.command_prefix),
        value = "A randomly generated inspirational quote generated by an AI.",
        inline = False
    )
    e.add_field(
        name = "{0}pick <<choice a, choice b, ...>>".format(bot.command_prefix),
        value = "Chooses a random item from a given list, delimited by a comma.",
        inline = False
    )
    
    await ctx.send(embed = e)


@bot.command()
async def ping(ctx):
    await ctx.send("{0} Pong! {1} ms :ping_pong:".format(ctx.message.author.mention, round(bot.latency * 1000)))

@bot.command()
async def say(ctx):
    message = ctx.message.clean_content[5:]
    await ctx.message.delete()
    await ctx.send(message)

@bot.command()
async def avatar(ctx):
    message = ctx.message.content[10: len(ctx.message.content) -1]
    message = message.replace("!", "")

    if len(message) != 0:
        if (not any(char.isdigit() for char in message) or bot.get_user(int(message)) == None):
            await ctx.send("Please input proper parameters.")
            return 
        username = bot.get_user(int(message)).name
        discrim = bot.get_user(int(message)).discriminator
        avatarURL = bot.get_user(int(message)).avatar_url

    else:
        username = ctx.message.author.name
        discrim = ctx.message.author.discriminator
        avatarURL = ctx.message.author.avatar_url

    e = discord.Embed(
        title = "Avatar for {0}#{1}".format(username, discrim),
        color = 0XFFDF00
    )

    e.set_image(url = avatarURL)
    await ctx.send(embed = e)  

@bot.command()
async def story(ctx, *, story):
    words = story.split(" ")
    result = ""

    for string in words:
        buffer = emoji.emojize(f":{string}:", True)
        if buffer == (f":{string}:"):
            result += buffer.replace(":", "") + " "
        else:    
            result += buffer + " "
    await ctx.send(result)


@bot.command()
async def whois(ctx):
    message = ctx.message.content[9: len(ctx.message.content) -1]
    message = message.replace("!", "")

    if len(message) != 0:
        if (not any(char.isdigit() for char in message) or bot.get_user(int(message)) == None):
            await ctx.send("Please input proper parameters.")
            return 
        username = bot.get_user(int(message)).name
        discrim = bot.get_user(int(message)).discriminator
        avatarURL = bot.get_user(int(message)).avatar_url

    else:
        username = ctx.message.author.name
        discrim = ctx.message.author.discriminator
        avatarURL = ctx.message.author.avatar_url
    
    e = discord.Embed(
        title = "Who is {0}?".format(username),
        color = 0XFFDF00
    )

    e.add_field(
        name = "Discriminator",
        value = discrim,
        inline = False
    )

    e.add_field(
        name = "ID",
        value = message,
        inline = False
    )

    await ctx.send(embed = e)

@bot.command()
async def stop(ctx):
    aID = 161998154881826826
    bID = 142404845234683904
    if ctx.message.author.id == aID or ctx.message.author.id == bID:
        await ctx.send("Bot Stopped :electric_plug:")
        await bot.logout()


@bot.command()
async def subreddit(ctx, *, subreddit):
    response = await ctx.send("◌ Collecting...")
    links = await find_reddit_link(subreddit)
    e = discord.Embed(
        title = "Posts from {0}".format(subreddit),
        description = "Top 5 posts from Hot.",
        color = 0XFFDF00
    )
    
    if(not type(links) is list):
        await ctx.send("Subreddit is " + links + ".")
        return
    for post in links[0: 5]:
        for key, val in post.items():
            e.add_field(
                name = key,
                value = val,
                inline = False
            )
            
    await response.delete()

    await ctx.send(embed = e)



@bot.command()
async def reddit(ctx, *, subreddit):
    response = await ctx.send("◌ Collecting...")
    links = await find_reddit_link(subreddit)
    randLink = links[random.randint(0, len(links) - 1 )]
    await response.delete()

    if(not type(links) is list):
        await ctx.send("Subreddit is " + links + ".")
        return
    for key, value in randLink.items():
        await ctx.send("__" + key + ":__\n" + value + "\n")
    
@bot.command()
async def anime(ctx, *, title):
    response = await ctx.send("◌ Hold on...")
    url = "https://twist.moe/a/" + title.lower().strip().replace(" ", "-")
    await response.delete()

    await ctx.send("Try this: " + url)

    """
    driver = webdriver.PhantomJS()
    driver.implicitly_wait(10)
    driver.get(url)
    soup = BeautifulSoup(driver.page_source)
    filename = "testb.txt"
    myfile = open(filename, "w")
    myfile.write(soup.prettify())
    myfile.close()
    headers = {'user-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.3'}
    request = urllib.request.Request(url,headers=headers)
    html = urllib.request.urlopen(request).read()
    soup = BeautifulSoup(html, 'html.parser')
    tag=soup.find('video')
    #print(tag) 
    """
@bot.command()
async def google(ctx, *, definition):
    response = await ctx.send("◌ Collecting...")
    temp = definition.replace(" ", "%20")
    url = "https://www.google.com/search?q=" + temp + "%20definition"
    headers = {'user-agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.3'}
    try:
        request = urllib.request.Request(url,headers=headers)
        html = urllib.request.urlopen(request).read()
        scrapper = BeautifulSoup(html,'html.parser')
        table = scrapper.find("div",attrs={'class':'lr_dct_sf_sen Uekwlc XpoqFe', 'class': 'PNlCoe XpoqFe'})
        links = table.find("span")
    except:
        await ctx.send("Cannot find definition for " + definition)
        return
    await response.delete()
    e = discord.Embed(
        title = "Definiton of " + definition,
        description = str(links)[6:len(str(links)) - 7],
        color = 0XFFDF00
    )
    e.set_footer(
        text="Source: " + url
    )
    await ctx.send(embed = e)

@bot.command()
async def verbose(ctx, *, sentence):
    reply = await ctx.send("◌ Generating...")
    result = ""
    for word in sentence.lower().split(" "):
        if len(word) <= 3:
            result += word + " "
            continue
        response = requests.get("https://api.datamuse.com/words?ml=" + word)
        data = response.json()
        if len(data) > 0:
            result += data[0]['word'] + " "
            continue
        result += word + " "

    """
    Concerns:
        1) Speed -> Each word needs to pull JSON from site, very time costly and as a result, large sentences take a long while
        2) Might need a dictionary to filter out some common words from getting thesaursed
        3a) Punctuation will ruin the search to empty. "word." -> [] aka no result. Punctuations must be taken out then re-placed after thesaurus.
        3b) Word contractions such as "don't" will ruin uri encode to search up "don%27t" -> "don", wrong word. For whatever reason, the first word returned is "does" which doesn't make sense 
        4) Currently picks the first result which is based on how confident the API is about how similar a word is to query. Playing with query combinations changes results (sometimes drastically).
    """
    await reply.delete()
    await ctx.send(result.capitalize())

@bot.command()
async def define(ctx, *, word):
    result = ""
    word = re.sub(r"[^a-zA-Z ]", "", word)
    response = requests.get("https://api.datamuse.com/words?sp=" + word + "&md=d")
    data = response.json()
    if len(data) > 0 and 'defs' in data[0]:
        df = 1
        for dfn in data[0]['defs']:
            # if not starts with a -> [2:] else [3:]
            if dfn.startswith("adj", 0, 3):
                result += f"{df}) [Adjective] {dfn[4:].capitalize()}\n"
                df += 1
            if dfn.startswith("adv", 0, 3):
                result += f"{df}) [Adverb] {dfn[4:].capitalize()}\n"
                df += 1
            if dfn.startswith("n", 0, 1):
                result += f"{df}) [Noun] {dfn[2:].capitalize()}\n"
                df += 1
            if dfn.startswith("v", 0, 1):
                result += f"{df}) [Verb] {dfn[2:].capitalize()}\n"
                df += 1
            if dfn.startswith("u", 0, 1):
                result += f"{df}) [Unknown] {dfn[2:].capitalize()}\n"
                df += 1
        e = discord.Embed(
            title = f"Definition of {word}",
            description = result,
            color = 0X4259F4
        )
        await ctx.send(embed = e)
    else:
        await ctx.send(f"Could not find a definition for {word}.")

@bot.command(name = "8ball")
async def eightball(ctx, *, question):
    response = []
    ## GOOD RESPONSE ##
    response.append(":green_book:|It is certain.|:green_book:")
    response.append(":green_book:|It is decidedly so.|:green_book:")
    response.append(":green_book:|Without a doubt.|:green_book:")
    response.append(":green_book:|Yes, definitely.|:green_book:")
    response.append(":green_book:|You may rely on it.|:green_book:")
    response.append(":green_book:|As I see it, yes.|:green_book:")
    response.append(":green_book:|Most likely.|:green_book:")
    response.append(":green_book:|Outlook good.|:green_book:")
    response.append(":green_book:|Yes.|:green_book:")
    response.append(":green_book:|Signs point to yes.|:green_book:")
    ## UNCERTAIN RESPONSE ##
    response.append(":ledger:|Reply hazy, try again.|:ledger:")
    response.append(":ledger:|Ask again later.|:ledger:")
    response.append(":ledger:|Better not tell you now.|:ledger:")
    response.append(":ledger:|Cannot predict now.|:ledger:")
    response.append(":ledger:|Concentrate and ask again.|:ledger:")
    ## BAD RESPONSE ##
    response.append(":closed_book:|Don't count on it.|:closed_book:")
    response.append(":closed_book:|My reply is no.|:closed_book:")
    response.append(":closed_book:|My sources say no.|:closed_book:")
    response.append(":closed_book:|Outlook not so good.|:closed_book:")
    response.append(":closed_book:|Very doubtful.|:closed_book:")
    await ctx.send(":8ball: {0} :8ball:\n\n{1}".format(question, response[randint(0, len(response)-1)]))

@bot.command()
async def inspiro(ctx):
    e = discord.Embed(
        description = f"{ctx.message.author.mention} needed a little inspiration.",
        color = 0X4259F4
    )
    e.set_image(
        url = requests.get("http://inspirobot.me/api?generate=true").text
    )
    e.set_footer(
        text = "Powered by inspirobot.me"
    )
    await ctx.send(embed = e)

@bot.command()
async def pick(ctx, *, s):
    choices = []
    [choices.append(x.strip()) for x in s.split(",") if x.strip() and x.strip() not in choices]
    if len(choices) == 0:
        await ctx.send("Doesn't look like there were any valid choices.")
    if len(choices) == 1:
        await ctx.send(f"Well, there was only one choice so... I picked {choices[0]}")
    await ctx.send(f"I picked {choices[randint(0, len(choices)-1)]}")


### Run
bot.run(read_token())